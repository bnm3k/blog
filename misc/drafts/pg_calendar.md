# Building a Reservation/Booking System with PostgreSQL

Let's build a reservation system using SQL & PostgreSQL. We are managing a
couple of rooms. Users will be able to reserve/book a room for a given amount of
time. Bookings should not overlap, that is, at a given instance, a room should
be booked by at most 1 user. As an aside, the 'object' being booked does not
have to be a room, it could be a restaurant table or a consultant's office hours
or anything.

Before proceeding, let's cover some preliminaries. Since we will be dealing with
time a lot, let's see what tools PG (PostgreSQL) provides us:

## Date/Time Postgres

Starting with the basics, Postgres provides us `date` and `time` values:

```sql
select  '2024-10-23'::date; -- ISO 8601
select '10:00 pm'::time
```

There is also the `interval` data type which represents the duration between two
points of time:

```sql
select '2 months 3 days 10 hours'::interval;
```

Postgres does provides ranges which 'are data types representing a range of
values of some element type' -
[PG Docs: Range Types](https://www.postgresql.org/docs/current/rangetypes.html).
Postgres comes with integer ranges, date ranges, timestamp ranges and so on.

To check if one range contains another, we use the containment operator `<@`:

```sql
select '[3,6)'::int4range <@ '[1,8)'::int4range;

-- true
```

To check if one range overlaps with another range, we use the overlaps operator
`&&`:

```sql
select '[1,10)'::int4range && '[5,15)'::int4range;

-- true
```

For more details, check out the following sections of the PG documentation:

- [Date/Time Types](https://www.postgresql.org/docs/current/datatype-datetime.html)
- [Date/Time Functions and Operators](https://www.postgresql.org/docs/current/functions-datetime.html)
- [Range Types](https://www.postgresql.org/docs/current/rangetypes.html)
- [Range/Multirange Functions and Operators](https://www.postgresql.org/docs/14/functions-range.html)

Back to the booking system:

## Rooms

We have rooms and people can book those rooms for a given period:

```sql
create table room(
    id int generated by default as identity primary key
);
```

We could capture more details about a given room such as its location, name,
active status and so on, but for now all we care about is the room's ID.

## Time Slots

The period a room's booked for consists of given day, plus the select time slot
within that day. For example, one could book room with ID 22 on Friday
(2024-11-22) from 2:00 pm to 4:00 pm.

The day can be stored using a
`[date](https://neon.tech/postgresql/postgresql-tutorial/postgresql-date)` data
type.

As for the time slot, we will use a
`[time](https://neon.tech/postgresql/postgresql-tutorial/postgresql-time)` data
type. The time slot could be stored in two separate `time` fields (`start_at`,
`end_at`). Better yet, we can use ranges. Only problem is that by default,
Postgres does provide us with time ranges. We will have to create time ranges
ourselves (relying on Postgres' extensibility that let's us define new kinds of
range, see the
[Defining New Range Types](https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DEFINING)
section of the PG docs).

Here is the `time_range` definition:

```sql
create function time_range_subtype_diff(x time, y time)
returns float8 as $$
    select extract(epoch from (x - y))
$$ language sql strict immutable;


create type time_range as range (
    subtype = time,
    subtype_diff = time_range_subtype_diff,
    multirange_type_name = time_multirange
);
```

The `subtype_diff` parameter is set to `time_range_subtype_diff` for a very
important reason, which will come in handy later on. From the docs:
([Defining New Range Types](https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DEFINING)):

> any range type that is meant to be used with GiST or SP-GiST indexes should
> define a subtype difference, or subtype_diff, function. (The index will still
> work without subtype_diff, but it is likely to be considerably less efficient
> than if a difference function is provided.) The subtype difference function
> takes two input values of the subtype, and returns their difference (i.e., X
> minus Y) represented as a float8 value.

The difference between any two `time` values is an interval:

```
> select diff, pg_typeof(diff)
  from (values ('10:30 am'::time - '8:00 am'::time)) v(diff)

   diff   │ pg_typeof
══════════╪═══════════
 02:30:00 │ interval
```

Intervals can be negative too:

```
> select ('10:00 am'::time - '10:00 pm'::time) as diff

   diff
═══════════
 -12:00:00
```

If we extract epoch from an interval, we get the total number of seconds within
that interval:

```
> select extract(epoch from '1 hour 20 minutes'::interval) as secs;

    secs
═════════════
 4800.000000
```

`time_range_subtype_diff` then combines the ability to subtract one time value
from another to get an interval then convert that interval into seconds.

Zooming back out, a booking consists of a room ID, date and `time_range` slot,
let us define the table that will hold bookings:

```sql
create table bookings(
    id int generated by default as identity primary key,
    room_id int not null references room(id) on delete cascade,
    day date not null,
    time_slot time_range not null
);
```

The `on delete cascade` clause ensures that if a room is deleted, the bookings
made at that room are also deleted. In the 'real-world', we would have to take
into account bookings that were made in the future and notify the users that
made those bookings that we are deleting the room.

Onwards, one of the key considerations for our system is that bookings do not
overlap. For this, we will have to use an exclusion constraint. From the
[docs](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-EXCLUSION),
exclusion constraints "ensure that if any two rows are compared on the specified
columns or expressions using the specified operators, at least one of these
operator comparisons will return false or null".

For our case, I would loosely define exclusion constraints as a means for
preventing entries within the bookings table from overlapping on all the given
dimensions (room id, day, time slot). If there are two bookings made on the same
day with the time slots overlapping, but they are made at different rooms, then
those bookings do not overlap. If there are two bookings made on the same room
with the time slots overlapping but at different days, then those bookings do
not overlap. For two or more bookings to overlap, they must be made at the same
room, on the same date, with the time slots overlapping.

Recall that we check whether ranges overlap using the `&&` operator:

```
>
select r1, r2, r1 && r2 as overlaps
from (values
    ('[00,10)'::int4range, '[10,20)'::int4range),
    ('[10,20)'::int4range, '[20,30)'::int4range),
    ('[10,20)'::int4range, '[10,20)'::int4range),
    ('[10,20)'::int4range, '[15,30)'::int4range)
) v(r1,r2)

   r1    │   r2    │ overlaps
═════════╪═════════╪══════════
 [0,10)  │ [10,20) │ f
 [10,20) │ [20,30) │ f
 [10,20) │ [10,20) │ t
 [10,20) │ [15,30) │ t
```

Let's add the exclusion constraint:

```sql
-- for a given date at a particular time, only one booking can be made
create extension if not exists btree_gist;

alter table bookings
    add constraint bookings_no_overlaps_excl
    exclude using gist(
        room_id with =,
        day with =,
        time_slot with &&
    );
```

GiST indexes let us index multi-dimensional data (such as ranges). `btree_gist`,
let's us index both multi-dimensional fields (such as ranges) and
uni-dimensional fields (such as room IDs or dates).

There is an additional constraint we could add though it is not as needed: let
us ensure that for all ranges inserted, the lower bound is inclusive and the
upperbound is exclusive:

```sql
alter table bookings
    add constraint bookings_lower_bound_inclusive_upper_bound_exclusive_check
    check (lower_inc(time_slot) = true and upper_inc(time_slot) = false);
```

There are a lot more constraints we could add, it all depends on our
application's needs.

Before proceeding any further, let's add some test data to play around with:

```sql
insert into room(id) values (1);

insert into bookings(room_id, day, time_slot) values
    (1, '2024-11-19', '[08:00, 12:30)'::time_range),
    (1, '2024-11-20', '[08:30, 10:00)'::time_range),
    (1, '2024-11-20', '[11:30, 12:30)'::time_range),
    (1, '2024-11-20', '[16:00, 18:00)'::time_range),
    (1, '2024-11-21', '[10:00, 11:00)'::time_range),
    (1, '2024-11-21', '[14:00, 16:00)'::time_range);
```

## Searching for Available Slots

When a user wants to make a booking, we first have to provide them all the
available slots.

First, let's start with the opposite, finding all the booked slots for room 1
for a given day

```sql
select id, time_slot
from bookings b
where day = '2024-11-20' and room_id = 1
```

This outputs:

```
 id │      time_slot
════╪═════════════════════
  2 │ [08:30:00,10:00:00)
  3 │ [11:30:00,12:30:00)
  4 │ [16:00:00,18:00:00)
```

Now, to find the available slots, there's a rather hairy SQL we could use:

```sql
with recursive selections(available, possible) as (
    select 'empty'::time_range, '[00:00,24:00)'::time_range
union
    select
        case
            when already_booked is null
                then possible
            when possible @> lower(booked)
                then time_range(lower(possible), lower(booked))
            else 'empty'::time_range
        end as available,
        case when possible @> upper(booked)
                then time_range(upper(booked), upper(possible))
            else 'empty'::time_range
        end as possible
    from selections
    left outer join lateral (
        select time_slot as booked from bookings
        where time_slot && selections.possible
        and day = '2024-11-20'
        and room_id = 1
        order by time_slot asc
        limit 1
    ) as already_booked on 't'
)
select available
from selections
where not isempty(available)
```

This outputs the following available slots:

```
      available
═════════════════════
 [00:00:00,08:30:00)
 [10:00:00,11:30:00)
 [12:30:00,16:00:00)
 [18:00:00,24:00:00)
```

I have gone over how this query works in an
[old blog post](https://github.com/bnm3k/old-blog/blob/master/13_ranges_difference/index.md).
I'll provide a quick summary instead:

- we start with the base case where we have a time range covering an entire day
  (`[00:00,24:00)`) as `possible` and 'empty' as the `available` slot.
- at each iteration, we find the earliest booking in the sub query that overlaps
  with the time range in `possible`: `join lateral ( ... )`
- in the first iteration, this will be `[08:30:00,10:00:00)`. Using this
  booking, we split the `possible` time range into two: `[00:00,08:30)` (the
  period before the booking) and `[10:00,'24:00')` (the period just after the
  booking). The former becomes an 'available' time slot and the latter becomes a
  'possible' time slot which we will check in the next iteration
- the query iterates until `possible` is exhausted i.e. empty

Recursive queries in Postgres can be quite fun and if you're interested, check
out this post I wrote a while back where I apply recursive queries to graph
problems:
([Graph Query Interfaces: A Comparison Between SQL and Cypher](/blog/sql-cypher-flights)).

That being said, PostgreSQL 14 introduced multiranges which vastly simplify our
query. With multiranges, the problem of finding all available ranges for a given
room is simplified into:

```sql
select '{[00:00,24:00)}' - range_agg(time_slot)
from bookings b
where day = '2024-11-20' and room_id = 1
```

Giving us the following:

```
                                     ?column?
═══════════════════════════════════════════════════════════════════════════════════
 {[00:00:00,08:30:00),[10:00:00,11:30:00),[12:30:00,16:00:00),[18:00:00,24:00:00)}
```

On unnesting the multirange:

```sql
select
    unnest('{[00:00,24:00)}' - range_agg(time_slot)) as available
from bookings b
where day = '2024-11-20' and room_id = 1
```

We get:

```
      available
═════════════════════
 [00:00:00,08:30:00)
 [10:00:00,11:30:00)
 [12:30:00,16:00:00)
 [18:00:00,24:00:00)
```

We are not quite done though.

## Operating Hours

Suppose we only allow bookings to be made within a certain period per given day
of the week. For example, on Monday, bookings can only be within 8:00 am in the
morning to 5:00 pm in the evening. Let's capture this requirement with the
following table:

```sql
create table operating_period(
    room_id int not null references room (id) on delete cascade,
    day_of_week int not null, -- iso day, 1 - monday, 7 - sunday
    open_during time_multirange not null,

    unique(room_id, day_of_week)
);
```

For day of the week, we'll the ISO week date whereby Monday is 1 and Sunday
is 7. `open_during` is a multi-range for compactness.

Room 1 will be open from 8:00 am to 1:00 pm and 2:00 pm to 10:00 pm on weekdays.
On Saturdays, it will be open from 9:00 am to 1:00 pm and on Sundays it will be
closed:

```sql
insert into operating_period(room_id, day_of_week, open_during)
select 1 as room_id, day, '{[8:00 am, 1:00 pm), [2:00 pm, 10:00 pm)}'
from unnest('{1,2,3,4,5}'::integer[]) u(day);

insert into operating_period(room_id, day_of_week, open_during)
select 1 as room_id, 6 as day, '{[9:00 am, 1:00 pm)}';
```

Suppose we want to know which periods on Tuesday Room 1 is closed (instead of
opened):

```sql
select
    '{[00:00, 24:00)}'::time_multirange  - open_during as closed
from operating_period
where room_id = 1 and day_of_week = 2
```

This outputs:

```
                  closed
═══════════════════════════════════════════
 {[00:00:00,08:00:00),[13:00:00,24:00:00)}
```

Let's check whether the bookings we made earlier all fall within the open
periods:

```sql
select
    b.id as booking_id,
    b.room_id,
    b.day,
    b.time_slot,
    b.time_slot <@ op.open_during as ok
from bookings b
left join operating_period op
    on b.room_id = op.room_id
    and extract(isodow from b.day) = op.day_of_week
```

Note the `b.time_slot <@ op.open_during` line where we use the `<@`
(containment) operator to check whether the booking time slots falls entirely
within the open period for that day. The query above outputs:

```
 booking_id │ room_id │    day     │      time_slot      │ ok
════════════╪═════════╪════════════╪═════════════════════╪════
          1 │       1 │ 2024-11-19 │ [08:00:00,12:30:00) │ t
          2 │       1 │ 2024-11-20 │ [08:30:00,10:00:00) │ t
          3 │       1 │ 2024-11-20 │ [11:30:00,12:30:00) │ t
          4 │       1 │ 2024-11-20 │ [16:00:00,18:00:00) │ t
          5 │       1 │ 2024-11-21 │ [10:00:00,11:00:00) │ t
          6 │       1 │ 2024-11-21 │ [14:00:00,16:00:00) │ t
```

If check constraints were flexible enough, we would capture the above
requirement as a constraint on the `bookings` table. Instead we will have to use
a before-insert trigger.

```sql
begin;

create function check_booking_within_operating_period()
returns trigger as $$
declare
    open_during_ time_multirange;
begin
    -- retrieve operating period for the room and day of the week
    select open_during into open_during_
    from operating_period op
    where op.room_id = NEW.room_id and
          op.day_of_week = extract(isodow from NEW.day);

    -- check if booking is within operating period for given room & day
    if not(NEW.time_slot <@ open_during_) or open_during_ is null then
        raise exception 'booking time_slot % is outside of operating period for room_id % given day %',
        NEW.time_slot, NEW.room_id, NEW.day;
    end if;

    return NEW;
end;
$$ language plpgsql;

create trigger enforce_booking_within_operating_period
before insert on bookings
for each row execute function check_booking_within_operating_period();

commit;
```

If you are new to Postgres Triggers, neon tech's
[PostgreSQL Triggers](https://neon.tech/postgresql/postgresql-triggers) series
offers a decent introduction. From there you can read through Postgres' docs for
more details.

With the trigger in place, let us try to insert a booking very early morning on
a Thursday:

```sql
insert into bookings(room_id, day, time_slot)
values (1,'2024-11-22', '[4:00,5:00)');
```

We get the following error:

```
ERROR:  P0001: booking time_slot [04:00:00,05:00:00) is outside of operating period for room_id 1 given day 2024-11-22
CONTEXT:  PL/pgSQL function check_booking_within_operating_period() line 13 at RAISE
LOCATION:  exec_stmt_raise, pl_exec.c:3870
```

What if we insert on Sunday when we don't take any bookings at all for room 1:

```sql
insert into bookings(room_id, day, time_slot)
values (1,'2024-11-24', '[10:00,11:30)');
```

We get the following error:

```
ERROR:  P0001: booking time_slot [10:00:00,11:30:00) is outside of operating period for room_id 1 given day 2024-11-24
CONTEXT:  PL/pgSQL function check_booking_within_operating_period() line 13 at RAISE
LOCATION:  exec_stmt_raise, pl_exec.c:3870
```

There is more requirements that we will have to take into account in the future:

- operating hours might change
- there are also holidays or select dates where we do not want to accept any
  bookings

## Building the Calendar

Given a room, we have booked slots, available slots and periods when the room is
closed. Let's build a calendar to capture all this information. We will focus on
a week's worth of data but the code can be extended to handle a month or even
the entire year.

Let's start with the basics. The `current_date` function returns the current
date. Using `date_trunc` with `week`, we can get the start of the week within
which that date falls. If we add a positive interval to date, we get a future
date. With these three, we can then get the start and end of our current week:

```sql
select
    (date_trunc('week', current_date))::date as start_at, --monday
    (date_trunc('week', current_date) + '6 days'::interval)::date  as end_at-- sunday
```

Which gives us:

```
  start_at  │   end_at
════════════╪════════════
 2024-11-18 │ 2024-11-24
```

To get all the dates (and the day of the week) that fall within the current
week, we will use `generate_series`:

```sql
with period(start_at, end_at) as (
    select
        (date_trunc('week', current_date))::date, --monday
        (date_trunc('week', current_date) + '6 days'::interval)::date -- sunday
)
select
    d::date as date,
    extract(isodow from d) as day
from period,
generate_series(start_at, end_at, '1 day'::interval) g(d)
```

Which outputs:

```
    date    │ day
════════════╪═════
 2024-11-18 │   1
 2024-11-19 │   2
 2024-11-20 │   3
 2024-11-21 │   4
 2024-11-22 │   5
 2024-11-23 │   6
 2024-11-24 │   7
```

Next, let us get all the closed periods for room 1 within that period. Recall
that the absence of an `open_during` for a given day implies that the room is
closed entirely for that day. That is why we're using a `left join`: for the
days where we do not have a corresponding row from `operating_period`, we'll get
`null` which will then be replaced with `{[00:00,24:00)}` using `coalesce`

```sql
select
    cw.date,
    coalesce(
        '{[00:00,24:00)}' - op.open_during,
        '{[00:00,24:00)}'
    ) as closed_during
from current_week cw
left join operating_period op on cw.day = op.day_of_week and op.room_id = 1
```

This outputs:

```
    date    │                         closed_during
════════════╪═══════════════════════════════════════════════════════════════
 2024-11-18 │ {[00:00:00,08:00:00),[13:00:00,14:00:00),[22:00:00,24:00:00)}
 2024-11-19 │ {[00:00:00,08:00:00),[13:00:00,14:00:00),[22:00:00,24:00:00)}
 2024-11-20 │ {[00:00:00,08:00:00),[13:00:00,14:00:00),[22:00:00,24:00:00)}
 2024-11-21 │ {[00:00:00,08:00:00),[13:00:00,14:00:00),[22:00:00,24:00:00)}
 2024-11-22 │ {[00:00:00,08:00:00),[13:00:00,14:00:00),[22:00:00,24:00:00)}
 2024-11-23 │ {[00:00:00,09:00:00),[13:00:00,24:00:00)}
 2024-11-24 │ {[00:00:00,24:00:00)}
```

Getting the bookings is straightforward:

```sql
select
    cw.date, range_agg(time_slot)
from current_week cw
join bookings b on b.day = cw.date and b.room_id = 1
group by cw.date
```

Which should output:

```
    date    │                           range_agg
════════════╪═══════════════════════════════════════════════════════════════
 2024-11-20 │ {[08:30:00,10:00:00),[11:30:00,12:30:00),[16:00:00,18:00:00)}
 2024-11-21 │ {[10:00:00,11:00:00),[14:00:00,16:00:00)}
 2024-11-19 │ {[08:00:00,12:30:00)}
```

Now that we have both bookings and closed periods, we can calculate the
available periods that were or are open for bookings:

```sql
select
    cw.date,
    ('{[00:00,24:00)}' - closed.time_slots - coalesce(booked.time_slots,'{}'))
    as available
from current_week cw
join closed using(date)
left join booked using(date)
```

Resulting in:

```
    date    │                                               available
════════════╪═══════════════════════════════════════════════════════════════════════════════════════════════════════
 2024-11-18 │ {[08:00:00,13:00:00),[14:00:00,22:00:00)}
 2024-11-19 │ {[12:30:00,13:00:00),[14:00:00,22:00:00)}
 2024-11-20 │ {[08:00:00,08:30:00),[10:00:00,11:30:00),[12:30:00,13:00:00),[14:00:00,16:00:00),[18:00:00,22:00:00)}
 2024-11-21 │ {[08:00:00,10:00:00),[11:00:00,13:00:00),[16:00:00,22:00:00)}
 2024-11-22 │ {[08:00:00,13:00:00),[14:00:00,22:00:00)}
 2024-11-23 │ {[09:00:00,13:00:00)}
 2024-11-24 │ {}
```

With everything in place, we can now construct the calendar:

```sql
with period(start_at, end_at) as (
    select
        (date_trunc('week', current_date))::date, --monday
        (date_trunc('week', current_date) + '6 days'::interval)::date -- sunday
), current_week(date,day) as (
    select
        d::date,
        extract(isodow from d)
    from period,
    generate_series(start_at, end_at, '1 day'::interval) g(d)
), closed(date, time_slots) as (
    select
        cw.date,
        coalesce(
            '{[00:00,24:00)}' - op.open_during,
            '{[00:00,24:00)}'
        ) as closed_during
    from current_week cw
    left join operating_period op on cw.day = op.day_of_week and op.room_id = 1
), booked(date, time_slots) as (
    select
        cw.date, range_agg(time_slot)
    from current_week cw
    join bookings b on b.day = cw.date and b.room_id = 1
    group by cw.date
), available(date, time_slots) as(
    select
        cw.date,
        ('{[00:00,24:00)}' - closed.time_slots - coalesce(booked.time_slots,'{}'))
        as available
    from current_week cw
    join closed using(date)
    left join booked using(date)
)

select day as date, time_slot, 'booked' as status, b.id as booking_id
from bookings b, period p
where b.day >= p.start_at and b.day <= p.end_at and b.room_id = 1

union all

select date, unnest(time_slots), 'available' as status, null as booking_id
from available

union all

select date, unnest(time_slots), 'closed' as status, null as booking_id
from closed

order by date asc, time_slot asc
```

Here's what we will get (I've formatted it a bit for ease of inspection):

```
    date    │      time_slot      │  status   │ booking_id
════════════╪═════════════════════╪═══════════╪════════════
 2024-11-18 │ [00:00:00,08:00:00) │ closed    │          ¤
            │ [08:00:00,13:00:00) │ available │          ¤
            │ [13:00:00,14:00:00) │ closed    │          ¤
            │ [14:00:00,22:00:00) │ available │          ¤
            │ [22:00:00,24:00:00) │ closed    │          ¤

 2024-11-19 │ [00:00:00,08:00:00) │ closed    │          ¤
            │ [08:00:00,12:30:00) │ booked    │          1
            │ [12:30:00,13:00:00) │ available │          ¤
            │ [13:00:00,14:00:00) │ closed    │          ¤
            │ [14:00:00,22:00:00) │ available │          ¤
            │ [22:00:00,24:00:00) │ closed    │          ¤

 2024-11-20 │ [00:00:00,08:00:00) │ closed    │          ¤
            │ [08:00:00,08:30:00) │ available │          ¤
            │ [08:30:00,10:00:00) │ booked    │          2
            │ [10:00:00,11:30:00) │ available │          ¤
            │ [11:30:00,12:30:00) │ booked    │          3
            │ [12:30:00,13:00:00) │ available │          ¤
            │ [13:00:00,14:00:00) │ closed    │          ¤
            │ [14:00:00,16:00:00) │ available │          ¤
            │ [16:00:00,18:00:00) │ booked    │          4
            │ [18:00:00,22:00:00) │ available │          ¤
            │ [22:00:00,24:00:00) │ closed    │          ¤

 2024-11-21 │ [00:00:00,08:00:00) │ closed    │          ¤
            │ [08:00:00,10:00:00) │ available │          ¤
            │ [10:00:00,11:00:00) │ booked    │          5
            │ [11:00:00,13:00:00) │ available │          ¤
            │ [13:00:00,14:00:00) │ closed    │          ¤
            │ [14:00:00,16:00:00) │ booked    │          6
            │ [16:00:00,22:00:00) │ available │          ¤
            │ [22:00:00,24:00:00) │ closed    │          ¤

 2024-11-22 │ [00:00:00,08:00:00) │ closed    │          ¤
            │ [08:00:00,13:00:00) │ available │          ¤
            │ [13:00:00,14:00:00) │ closed    │          ¤
            │ [14:00:00,22:00:00) │ available │          ¤
            │ [22:00:00,24:00:00) │ closed    │          ¤

 2024-11-23 │ [00:00:00,09:00:00) │ closed    │          ¤
            │ [09:00:00,13:00:00) │ available │          ¤
            │ [13:00:00,24:00:00) │ closed    │          ¤

 2024-11-24 │ [00:00:00,24:00:00) │ closed    │          ¤
```

We ought to expect more reads (of the calendar) than writes (into the bookings
and operating_hours tables). Therefore, it's worth caching calendar results.
However, we will have to keep the cached results consistent with the current
state of the database. I'm working on this currently, if you've got a solution
please reach out. I've glanced over both [materialize](https://materialize.com/)
and [feldera](https://www.feldera.com/) but they both don't support all the data
types and operators from PostgreSQL 17 that I have used so I'll have to figure
out how to transmute the data before connecting Materialize or Feldera.
Alternatively, I'm also thinking of using
[Jonathan Katz' approach](https://www.youtube.com/watch?v=Obvj9znL1IM) whose
talk pretty much inspired this post. Stay tuned!
